# SQL 11

관계명 데이터베이스를 제어하기 위한 언어이다.

## 데이터 모델과 성능

### 대량 데이터에 따른 성능

#### 1. 성능 저하 원인

- A 한 테이블에 데이터 대량 집중
- A 한 테이블에 여러 컬럼 존재
- B 대량 데이터 처리되는 테이블
- B 대량 데이터가 한 테이블에 존재
- 컬럼이 많아질 경우

#### 2. 해결 방안

- A 한 테이블에 많은 컬럼 - 수직분할
- B 대량 데이터 저장 문제 - 수평분할 (파티셔닝 or PK에 의한 테이블 분할)

#### 3. 로우 체이닝과 로우 마이그레이션

- 로우 체이닝: 행 길이가 길어서, 데이터블록 하나에 데이터를 모두 저장하지 않고,  **두 개 이상의 블록에 걸쳐서 하나의 로우를 저장**하는 형태 
  - 한 로우를 여러 체인처럼 -> 1:1로 테이블을 분리하면 -> 디스크 I/O가 줄어 -> 조회 성능 향상

- 로우 마이그레이션: 데이터블록에서 수정 발생 시, 수정된 데이터를 해당 블록에 저장하지 못하고 **다른 블록에 빈 공간을 찾아 저장**하는 방식

- 파티셔닝: 한 테이블에 많은 데이터가 저장되면, 테이블 아무리 쪼개도 성능이 저하되기 때문에  **논리적으로는 하나의 테이블이지만, 물리적으로는 여러 개의 테이블로 분리**된 형태

#### 4. 수직 / 수평 분할 절차

1. **데이터 모델** 완성
2. **DB 용량 산정**
3. 대량 데이터가 처리되는 테이블에 대해 **트랜잭션 처리 패턴 분석**
4. **컬럼 or 로우 단위**로 집중화된 처리가 발생하는지 분석해 **테이블 분리**

### 데이터베이스 구조와 성능

#### 1. 슈퍼 / 서브타입 데이터 모델

- 논리적 데이터 모델에서 주로 이용 (분석단계에서 많이 쓰임)
- 물리적 데이터 모델로 설계 시 문제 발생
- 슈퍼타입: **공통 부분**을 슈퍼타입으로 모델링
- 서브타입: 공통으로 상속받아 **다른 엔터티와 차이가 있는 속성만** 모델링

#### 2. 데이터베이스 성능 저하 원인 3가지

- 트랜잭션 - 일괄처리 / 테이블 - 개별 유지 -> **Union 연산에 의해 성능저하**
- 트랜잭션 - 슈퍼 + 서브 공통 처리 / 테이블 - 개별 유지 -> **join에 의해 성능저하**
- 트랜잭션 - 서브타입만 개별 처리 / 테이블 - 하나로 통합 -> **불필요하게 많은 데이터 집적**

#### 3. 슈퍼 / 서브 타입의 변환 기준

- 데이터가 소량일 경우: 데이터 처리 유연성 고려해 1:1 관계를 유지
- 데이터가 대량일 경우
  - 전부 개별 테이블로 구성
  - 슈퍼+서브타입 테이블로 구성
  - 하나의 테이블로 구성

#### 4. 슈퍼 / 서브 타입의 데이터 모델 변환 기술

- 개별로 발생되는 트랜잭션 -> 개별 테이블로 구성 (One to One type) 
- 슈퍼+서브타입으로 발생되는 트랜잭션 -> 슈퍼+서브타입 테이블로 구성 (Plus type) 
- 전체를 하나로 묶어 발생하는 트랜잭션 -> 하나의 테이블로 구성 (Single type)

> 쪼개질수록 확장성 up, Disk I/O 성능 up, 조인 성능 down, 관리 용이성 down

#### 5. PK / FK 컬럼 순서 및 성능

- 일반적인 프로젝트에선 PK/FK 컬럼 순서의 중요성을 인지하지 못해서  데이터 모델링된 그 상태대로 DDL을 생성하여 성능이 저하됨
- 인덱스 중요성: 데이터 조작 시 가장 효과적으로 처리될 수 있는 **접근 경로 제공** 오브젝트 **앞쪽에 위치한 속성값(컬럼)이 비교자**로 있어야 인덱스가 좋은 효율을 냄
- PK / FK 설계 중요성: **데이터 접근 시 접근경로 제공**, 설계단계 마지막에 **컬럼 순서를 조정**
- PK 순서 중요성: 물리적 모델링 단계에서 스스로 생성된 PK 외에 **상속되는 PK 순서도 중요**
- FK 순서 중요성: **조인을 할 수 있는 수단이 됨(=경로)** , 조회 조건 고려해서 반드시 인덱스 생성

#### 6. 인덱스 엑세스 범위 좁히는 가장 좋은 방법

- PK가 여러 개일 때, Where절에서 사용하는 조건용 컬럼들이 우선순위가 되어야 함
- **‘=’ EQUAL조건 (동등조건)**에 있는 컬럼이 제일 앞으로
- **BETWEEN, IN (범위조건)**에 있는 컬럼이 그 다음순위
- 나머지 PK는 그 뒤에 아무렇게나. (id값 이런거 상관없음)

#### 7. PK 순서를 조정하지 않으면 성능이 저하되는 이유

- 조회 조건(WHERE)에 따라 인덱스를 처리하는 범위가 달라짐
- PK의 순서를 인덱스 특징에 맞게 생성하지 않고 자동으로 생성하면, 테이블에 접근하는 트랜잭션이 **인덱스 범위를 넓게 하거나 Full Scan을 유발**

#### 8. 물리적 테이블에 FK 제약이 걸려있지 않은 경우, 인덱스 미생성으로 생긴 성능 저하

- 물리적으로 두 테이블 사이 FK 참조 무결성 관계를 걸어 상속받은 FK에 인덱스 생성